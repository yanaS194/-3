# -*- coding: utf-8 -*-
"""Копия блокнота "Практика 1.1.0.ipynb"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dxQHLfJQtihR7GC2kWyd_ongoyNGEqeq

**ФИО:**
"""

Смирнова Яна Александровна

"""# Задание 1

**Описание:** Создайте иерархию классов для разных типов сотрудников в компании. Реализуйте родительский класс Employee и дочерние классы Manager и Developer. Каждый класс должен иметь метод для расчета зарплаты на основе различных критериев класса.


Отрабатываемый принцип: Наследование
"""

class Employee:
    def __init__(self, name, base_salary):
        self.name = name
        self.base_salary = base_salary
    def calculate_salary(self):
        return self.base_salary
    def __str__(self):
        return f"{self.__class__.__name__}: {self.name}, Зарплата: {self.calculate_salary()}"
class Manager(Employee):
    def __init__(self, name, base_salary, bonus):
        super().__init__(name, base_salary)
        self.bonus = bonus
    def calculate_salary(self):
        return self.base_salary + self.bonus
class Developer(Employee):
    def __init__(self, name, base_salary, projects_completed):
        super().__init__(name, base_salary)
        self.projects_completed = projects_completed

    def calculate_salary(self):
        project_bonus = 1000 * self.projects_completed
        return self.base_salary + project_bonus
def main():
    employees = [
        Manager("Иван Иванов", 50000, 10000),
        Developer("Петр Петров", 40000, 5),
        Developer("Светлана Светлова", 45000, 3)
    ]
    for employee in employees:
        print(employee)
if __name__ == "__main__":
    main()

"""# Задание 2

**Описание:** Создайте иерархию классов для различных типов транспортных средств (Необходим один родительский класс и 3 дочерних). Реализуйте метод, который позволяет каждому транспортному средству возвращать собственное описание (Метод в каждом классе должен иметь одинаковое название). Продемонстрируйте вызов данного метода для каждого транспортного средства.


Отрабатываемый принцип: Полиморфизм
"""

class Vehicle:
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year
    def get_description(self):
        return f"{self.year} {self.make} {self.model}"

class Car(Vehicle):
    def __init__(self, make, model, year, doors):
        super().__init__(make, model, year)
        self.doors = doors
    def get_description(self):
        return f"{super().get_description()} - Количество дверей: {self.doors}"

class Bike(Vehicle):
    def __init__(self, make, model, year, handlebar_type):
        super().__init__(make, model, year)
        self.handlebar_type = handlebar_type
    def get_description(self):
        return f"{super().get_description()} - Тип руля: {self.handlebar_type}"

class Truck(Vehicle):
    def __init__(self, make, model, year, load_capacity):
        super().__init__(make, model, year)
        self.load_capacity = load_capacity
    def get_description(self):
        return f"{super().get_description()} - Грузоподъемность: {self.load_capacity} кг"
def main():
    vehicles = [
        Car("Toyota", "Camry", 2020, 4),
        Bike("Yamaha", "YZF-R3", 2019, "Sport"),
        Truck("Ford", "F-150", 2021, 3000)
    ]
    for vehicle in vehicles:
        print(vehicle.get_description())
if __name__ == "__main__":
    main()

"""# Задание 3

Онлайн-магазин:
- Создайте модель для онлайн-магазина с классами Product, Order, Customer, и ShoppingCart.
- Product включает информацию о цене, наличии на складе и категории товара.
Order обрабатывает процесс покупки, включая расчет цены с учетом скидок и налогов.
- Customer управляет информацией о пользователе и его истории заказов.
- ShoppingCart позволяет добавлять, удалять и обновлять количество товаров перед оформлением заказа.
"""

class Product:
    def __init__(self, name, price, stock, category):
        self.name = name
        self.price = price
        self.stock = stock
        self.category = category
    def is_in_stock(self):
        return self.stock > 0
    def reduce_stock(self, quantity):
        if quantity <= self.stock:
            self.stock -= quantity
            return True
        return False
    def __str__(self):
        return f"{self.name} - {self.price}₽ - {self.stock} в наличии"

class Order:
    def __init__(self, customer):
        self.customer = customer
        self.items = []
        self.total_price = 0.0
        self.discount = 0.0
        self.tax_rate = 0.2
    def add_item(self, product, quantity):
        """Добавляет товар в заказ."""
        if product.reduce_stock(quantity):
            self.items.append((product, quantity))
            self.total_price += product.price * quantity
        else:
            print(f"Недостаточно товара на складе для {product.name}")
    def apply_discount(self, discount):
        self.discount = discount
    def calculate_total(self):
        discounted_price = self.total_price * (1 - self.discount)
        total_with_tax = discounted_price * (1 + self.tax_rate)
        return total_with_tax
    def __str__(self):
        items_str = ', '.join([f"{quantity} x {product.name}" for product, quantity in self.items])
        return f"Заказ для {self.customer.name}: {items_str}, Общая сумма: {self.calculate_total():.2f}₽"

class Customer:
    def __init__(self, name, email):
        self.name = name
        self.email = email
        self.orders = []
    def add_order(self, order):
        self.orders.append(order)
    def __str__(self):
        return f"Клиент: {self.name}, Email: {self.email}, Количество заказов: {len(self.orders)}"

class ShoppingCart:
    def __init__(self):
        self.items = {}
    def add_product(self, product, quantity):
        if product.is_in_stock():
            if product in self.items:
                self.items[product] += quantity
            else:
                self.items[product] = quantity
            product.reduce_stock(quantity)
        else:
            print(f"{product.name} отсутствует на складе.")
    def remove_product(self, product):
        if product in self.items:
            del self.items[product]
    def update_quantity(self, product, quantity):
        if product in self.items:
            if quantity <= product.stock + self.items[product]:  # Проверка, можно ли обновить
                product.reduce_stock(quantity - self.items[product])
                self.items[product] = quantity
            else:
                print(f"Недостаточно товара на складе для обновления {product.name} до {quantity}.")
        else:
            print(f"{product.name} отсутствует в корзине.")
    def checkout(self, customer):
        order = Order(customer)
        for product, quantity in self.items.items():
            order.add_item(product, quantity)
        customer.add_order(order)
        self.items.clear()
        return order
    def __str__(self):
        items_str = ', '.join([f"{quantity} x {product.name}" for product, quantity in self.items.items()])
        return f"Корзина: {items_str}"

if __name__ == "__main__":
    product1 = Product("Ноутбук", 1200, 5, "Электроника")
    product2 = Product("Наушники", 100, 10, "Аксессуары")
    customer = Customer("Алиса", "alice@example.com")
    cart = ShoppingCart()
    cart.add_product(product1, 1)
    cart.add_product(product2, 2)
    order = cart.checkout(customer)
    print(order)

"""# Задание 4

Симулятор космического корабля:
- Создайте симулятор управления космическим кораблем с классами SpaceShip, CrewMember, и Mission.
- SpaceShip имеет атрибуты для управления топливом, состоянием корпуса, и текущей скоростью.
- CrewMember контролирует здоровье, навыки, и роли в команде (например, пилот, инженер).
- Mission определяет цели, ресурсы, и возможные события (например, аварии, встречи с астероидами).
"""

import random

class SpaceShip:
    def __init__(self, name, fuel, hull_integrity, speed=0):
        self.name = name
        self.fuel = fuel
        self.hull_integrity = hull_integrity
        self.speed = speed
    def accelerate(self, increase):
        if self.fuel <= 0:
            print("Недостаточно топлива для ускорения!")
            return
        self.speed += increase
        self.fuel -= increase * 0,1
        print(f"{self.name} ускорился до {self.speed} м/с. Осталось топлива: {self.fuel:.2f}")
    def decelerate(self, decrease):
        self.speed = max(0, self.speed - decrease)
        print(f"{self.name} замедлился до {self.speed} м/с.")
    def damage_hull(self, damage):
        self.hull_integrity -= damage
        if self.hull_integrity <= 0:
            print(f"{self.name} был уничтожен!")
        else:
            print(f"Целостность корпуса {self.name}: {self.hull_integrity:.2f}")
    def __str__(self):
        return f"Космический корабль: {self.name}, Топливо: {self.fuel:.2f}, Целостность корпуса: {self.hull_integrity:.2f}, Скорость: {self.speed} м/с"
class CrewMember:
    def __init__(self, name, health, skills, role):
        self.name = name
        self.health = health
        self.skills = skills
        self.role = role
    def take_damage(self, damage):
        self.health -= damage
        if self.health <= 0:
            print(f"{self.name} погиб!")
        else:
            print(f"Здоровье {self.name}: {self.health:.2f}")
    def __str__(self):
        return f"Член экипажа: {self.name}, Здоровье: {self.health:.2f}, Роль: {self.role}, Навыки: {self.skills}"
class Mission:
    def __init__(self, name, objectives, resources):
        self.name = name
        self.objectives = objectives
        self.resources = resources
        self.events = ["Встреча с астероидом", "Утечка топлива", "Системный сбой"]
    def simulate_event(self):
        event = random.choice(self.events)
        print(f"Событие миссии: {event}")
        return event
    def __str__(self):
        return f"Миссия: {self.name}, Цели: {self.objectives}, Ресурсы: {self.resources}"

if __name__ == "__main__":
spaceship = SpaceShip("Галактический Искатель", fuel=100, hull_integrity=100)
    pilot = CrewMember("Джон", health=100, skills=["Навигация", "Пилотирование"], role="Пилот")
    engineer = CrewMember("Эмили", health=100, skills=["Ремонт", "Инженерия"], role="Инженер")
    mission = Mission("Исследовать Альфа Центавра", objectives=["Собрать образцы", "Составить карту звезд"], resources={"Топливо": 50, "Еда": 100})
    print(spaceship)
    spaceship.accelerate(20)
    spaceship.accelerate(15)
    print(pilot)
    print(engineer)
    event = mission.simulate_event()
    if event == "Встреча с астероидом":
        spaceship.damage_hull(30)
        pilot.take_damage(10)
    elif event == "Утечка топлива":
        spaceship.fuel -= 20
        print(f"Утечка топлива! Текущее топливо: {spaceship.fuel:.2f}")
    elif event == "Системный сбой":
        spaceship.damage_hull(10)
        engineer.take_damage(5)
    print(spaceship)

"""# Дополнительно:

**Описание:** создайте консольную версию игры крестики-нолики, используя классы
"""

