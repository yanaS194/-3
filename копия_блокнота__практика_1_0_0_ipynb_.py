# -*- coding: utf-8 -*-
"""Копия блокнота "Практика 1.0.0.ipynb"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LpktoBvEfkYry-V0CJ813TXHZMzoKgpI

ФИО: Смирнова Яна Александровна

# Задание (совместное с преподавателем)

Напишите систему для учёта отпусков с возможностью узнавать, сколько дней отпуска осталось у того или иного сотрудника.
Для этого создайте класс Employee со следующими методами:

- Метод consume_vacation должен отвечать за списание дней отпуска.

Единственный параметр этого метода (кроме self) — количество потраченных отпускных дней (целое число).

При вызове метода consume_vacation соответствующее количество дней должно вычитаться из общего числа доступных отпускных дней сотрудника.

Чтобы определить число доступных отпускных дней конкретного сотрудника, в классе опишите атрибут экземпляра |, который по умолчанию будет равен значению атрибута класса vacation_days, и используйте этот атрибут в работе метода.

- Метод get_vacation_details должен возвращать остаток отпускных дней сотрудника в формате: ```Остаток отпускных дней: <число>.```


Чтобы проверить работу программы:
1. Создайте экземпляр класса Employee.
2. Вызовите метод consume_vacation, указав подходящее значение аргумента, например 7.
3. Вызовите метод get_vacation_details.
"""



"""# Задание 1

Задание:

Создайте класс с именем Rectangle который имеет:
- Атрибуты ширины и высоты.
- Метод расчета площади.
- Метод расчета периметра.
- Метод отображения размеров прямоугольника.

Создайте экземпляр класса Rectangleи продемонстрируйте его функциональность.
"""

class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
    def area(self):
        return self.width * self.height
    def perimeter(self):
        return 2 * (self.width + self.height)
    def display_dimensions(self):
        print(f"Ширина: {self.width}, Высота: {self.height}")
rectangle = Rectangle(10, 5)
rectangle.display_dimensions()
print(f"Площадь: {rectangle.area()}")
print(f"Периметр: {rectangle.perimeter()}")

"""# Задание 2

Задание: Создайте мини версию банковской системы:


Инструкции:

1. Создайте класс BankAccountсо следующими атрибутами:
    - account_holder -  владелец счета
    - balance - баланс счета

2. Реализуйте следующие методы:
    - Метод для инициализации владельца счета: имя владельца счета и установите начальный баланс на 0.
    - deposit(amount): Добавьте указанную сумму к балансу.
    - withdraw(amount): Вычесть указанную сумму из баланса, если средств достаточно; в противном случае вывести предупреждение.
    - get_balance(): Возврат текущего баланса.


Создайте объект класса и продемонстрируйте его возможности
"""

class BankAccount:
    def __init__(self, account_holder):
        self.account_holder = account_holder
        self.balance = 0
    def deposit(self, amount):
        if amount > 0:
            self.balance += amount
            print(f"{amount} добавлено. Новый баланс: {self.balance}")
        else:
            print("Сумма депозита должна быть положительной!")
    def withdraw(self, amount):
        if amount > 0:
            if amount <= self.balance:
                self.balance -= amount
                print(f"{amount} снято. Новый баланс: {self.balance}")
            else:
                print("Недостаточно средств на счете!")
        else:
            print("Сумма снятия должна быть положительной!")
    def get_balance(self):
        return self.balance
account_holder_name = input("Введите имя владельца счета: ")
account = BankAccount(account_holder_name)
account.deposit(100)
account.withdraw(50)
account.withdraw(70)
print(f"Текущий баланс: {account.get_balance()}")

"""# Задание 3

Возьмите код и задание (Рыцарь и дракон) из предыдущей практики и реализуйте его с применением классов
"""

import random
class Character:
    def __init__(self, name, armor, weapon, damage_range, health):
        self.name = name
        self.armor = armor
        self.weapon = weapon
        self.damage_range = damage_range
        self.health = health
    def attack(self):
        damage = random.randint(self.damage_range[0], self.damage_range[1])
        print(f"{self.name} атакует с оружием {self.weapon} и наносит {damage} урона!")
        return damage
    def take_damage(self, damage):
        effective_damage = max(0, damage - self.armor)
        self.health -= effective_damage
        print(f"{self.name} получил {effective_damage} урона и теперь имеет {self.health} здоровья.")
    def is_alive(self):
        return self.health > 0
class Knight(Character):
    def __init__(self, name):
        super().__init__(name, armor=5, weapon="меч", damage_range=(5, 15), health=100)
class Dragon(Character):
    def __init__(self, name):
        super().__init__(name, armor=3, weapon="огненное дыхание", damage_range=(10, 20), health=80)
def battle(knight, dragon):
    print(f"{knight.name} встречает {dragon.name} на поле боя!\n")
    while knight.is_alive() and dragon.is_alive():
        damage_to_dragon = knight.attack()
        dragon.take_damage(damage_to_dragon)
        if not dragon.is_alive():
            print(f"{dragon.name} повержен! {knight.name} победил!")
            break
        damage_to_knight = dragon.attack()
        knight.take_damage(damage_to_knight)
        if not knight.is_alive():
            print(f"{knight.name} повержен! {dragon.name} победил!")
            break
def main():
    print("Добро пожаловать в игру 'Рыцарь и Дракон'!")
    knight_name = input("Введите имя вашего рыцаря: ")
    knight = Knight(knight_name)
    dragon_name = input("Введите имя дракона: ")
    dragon = Dragon(dragon_name)
    print(f"\n{knight.name} сражается с {dragon.name}!\n")
    battle(knight, dragon)
if __name__ == "__main__":
    main()

"""# Дополнительное задание

Задача: Система управления библиотекой

**Цель**
Создайте простую систему управления библиотекой, которая позволит пользователям добавлять книги, брать книги, возвращать книги и просматривать список доступных книг.

**Требования**

1. **Определение класса**:
   – Создайте класс с именем «Book» со следующими атрибутами:
     - `title`
     - `автор`
     - `isbn`
     - `is_borrowed` (по умолчанию `False`)

2. **Класс библиотеки**:
   - Создайте класс с именем Library, который управляет коллекцией книг.
   - Класс должен иметь следующие методы:
     - `__init__(self)`: инициализирует пустой список книг.
     - `add_book(self, book: Book)`: добавляет новую книгу в библиотеку.
     - `borrow_book(self, isbn: str)`: помечает книгу как заимствованную. Если книга не найдена или уже взята, выведите соответствующее сообщение.
     - `return_book(self, isbn: str)`: помечает книгу как возвращенную. Если книга не найдена или не была взята взаймы, выведите соответствующее сообщение.
     - `list_available_books(self)`: печатает список всех доступных книг в библиотеке.
     - `find_book(self, isbn: str)`: возвращает объект книги, если он найден, в противном случае возвращает `None`.

3. **Взаимодействие с пользователем**:
   - Создайте простое текстовое меню, которое позволит пользователям:
     - Добавить книгу
     - Одолжить книгу
     - Вернуть книгу
     - Список доступных книг
     - Выйти из программы
"""

class Book:
    def __init__(self, title, author, isbn):
        self.title = title
        self.author = author
        self.isbn = isbn
        self.is_borrowed = False

    def __str__(self):
        status = "Доступна" if not self.is_borrowed else "Занята"
        return f"{self.title} by {self.author} (ISBN: {self.isbn}) - {status}"

class Library:
    def __init__(self):
        self.books = []
    def add_book(self, book: Book):
        self.books.append(book)
        print(f"Книга '{book.title}' добавлена в библиотеку.")
    def borrow_book(self, isbn: str):
        book = self.find_book(isbn)
        if book:
            if not book.is_borrowed:
                book.is_borrowed = True
                print(f"Вы одолжили книгу '{book.title}'.")
            else:
                print(f"Книга '{book.title}' уже взята.")
        else:
            print("Книга с таким ISBN не найдена.")
    def return_book(self, isbn: str):
        book = self.find_book(isbn)
        if book:
            if book.is_borrowed:
                book.is_borrowed = False
                print(f"Вы вернули книгу '{book.title}'.")
            else:
                print(f"Книга '{book.title}' не была взята взаймы.")
        else:
            print("Книга с таким ISBN не найдена.")

    def list_available_books(self):
        available_books = [book for book in self.books if not book.is_borrowed]
        if available_books:
            print("Доступные книги в библиотеке:")
            for book in available_books:
                print(book)
        else:
            print("Нет доступных книг в библиотеке.")

    def find_book(self, isbn: str):
        for book in self.books:
            if book.isbn == isbn:
                return book
        return None
def main():
    library = Library()
    while True:
        print("\nМеню:")
        print("1. Добавить книгу")
        print("2. Одолжить книгу")
        print("3. Вернуть книгу")
        print("4. Список доступных книг")
        print("5. Выйти")
        choice = input("Выберите действие: ")
        if choice == "1":
            title = input("Введите название книги: ")
            author = input("Введите автора книги: ")
            isbn = input("Введите ISBN книги: ")
            book = Book(title, author, isbn)
            library.add_book(book)
        elif choice == "2":
            isbn = input("Введите ISBN книги для одалживания: ")
            library.borrow_book(isbn)
        elif choice == "3":
            isbn = input("Введите ISBN книги для возврата: ")
            library.return_book(isbn)
        elif choice == "4":
            library.list_available_books()
        elif choice == "5":
            print("Вы вышли из программы.")
            break
        else:
            print("Неизвестный выбор. Пожалуйста, выберите снова.")
if __name__ == "__main__":
    main()