# -*- coding: utf-8 -*-
"""Копия блокнота "Практика 0.8.0.ipynb"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kNf-MudcR8DTPi5SzBFE67mm6wMWnxhW

# Задание 1

Задача: Создать чат бота для получения информации об исследованиях космоса

Описание: Создайте комплексное приложение командной строки, которое будет использоваться в качестве панели управления исследованиями космоса. Данное приложение будет обращаться к https://api.nasa.gov/ для предоставления пользователям набора информации о космосе, включая:

- Астрономическая картинка дня (APOD): Отображение APOD с пояснениями к нему.
- Фотографии с марсохода: позволяет пользователям выбирать и фильтровать фотографии с марсохода по дате и типу камеры.
- Объекты, сближающиеся с Землей (ОСЗ): Поиск и отображение информации об объекте, сближающихся с Землей, на определенную дату, включая их размеры и потенциальную опасность.
- Данные о космической погоде: Отображают последние данные о космической погоде, включая солнечные вспышки и геомагнитные бури.
Приложение должно позволять пользователям ориентироваться в этих функциях, корректно обрабатывать ошибки и обеспечивать удобство работы.

Требования:
- Пользовательский ввод: Приложение должно предложить пользователю ввести данные, чтобы выбрать, какую функцию он хочет изучить.
- Проверка данных: Убедитесь, что пользовательские данные (например, даты) проверены.
- Обработка ошибок: Корректно обрабатывайте ошибки API и неверные ответы.
- Представление данных: Представляйте данные в четкой и организованной форме.
- Опция выхода: позволяет пользователям выходить из приложения в любое время.
"""

pip install requests

import requests

API_KEY = 'DEMO_KEY'

def get_apod():
    url = f"https://api.nasa.gov/planetary/apod?api_key={API_KEY}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        print("Астрономическая картинка дня:")
        print(f"Заголовок: {data['title']}")
        print(f"Дата: {data['date']}")
        print(f"Описание: {data['explanation']}")
        print(f"URL: {data['url']}")
    else:
        print("Ошибка получения данных APOD.")

def get_mars_photos():
    rover = input("Введите название марсохода (Curiosity, Opportunity, Spirit): ")
    date = input("Введите дату (YYYY-MM-DD): ")
    url = f"https://api.nasa.gov/mars-photos/api/v1/rovers/{rover}/photos?earth_date={date}&api_key={API_KEY}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        photos = data.get('photos', [])
        if photos:
            print(f"Фотографии с марсохода {rover} на дату {date}:")
            for photo in photos:
                print(f"URL: {photo['img_src']}")
        else:
            print("Нет фотографий для данной даты.")
    else:
        print("Ошибка получения данных о фотографиях с марсохода.")

def get_near_earth_objects():
    date = input("Введите дату (YYYY-MM-DD): ")
    url = f"https://api.nasa.gov/neo/rest/v1/feed?start_date={date}&end_date={date}&api_key={API_KEY}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        if 'near_earth_objects' in data:
            print(f"Объекты, сближающиеся с Землей на {date}:")
            for obj in data['near_earth_objects'][date]:
                print(f"Название: {obj['name']}, Размер: {obj['estimated_diameter']['meters']['estimated_diameter_max']} м, Потенциальная опасность: {obj['is_potentially_hazardous_asteroid']}")
        else:
            print("Нет объектов, сближающихся с Землей на данную дату.")
    else:
        print("Ошибка получения данных о сближающихся объектах.")

def get_space_weather():
    url = f"https://api.nasa.gov/DONKI/FLR?api_key={API_KEY}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        print("Последние данные о космической погоде:")
        for flare in data:
            print(f"Дата: {flare['beginTime']}, Уровень: {flare['intensity']}")
    else:
        print("Ошибка получения данных о космической погоде.")

def main():
    while True:
        print("\nДобро пожаловать в панель управления исследованиями космоса!")
        print("Выберите одну из следующих опций:")
        print("1. Астрономическая картинка дня (APOD)")
        print("2. Фотографии с марсохода")
        print("3. Объекты, сближающиеся с Землей (ОСЗ)")
        print("4. Данные о космической погоде")
        print("5. Выход")

        choice = input("Ваш выбор: ")

        if choice == '1':
            get_apod()
        elif choice == '2':
            get_mars_photos()
        elif choice == '3':
            get_near_earth_objects()
        elif choice == '4':
            get_space_weather()
        elif choice == '5':
            print("Выход из приложения.")
            break
        else:
            print("Неверный выбор, попробуйте снова.")

if __name__ == "__main__":
    main()

"""# Задание 2

Описание задачи

Цель этой задачи - создать скрипт на Python, который взаимодействует с API Чикагского института искусств (https://api.artic.edu/docs/) для извлечения и отображения произведений искусства. Скрипт должен позволять пользователям просматривать работы по страницам, фильтровать их по имени художника и просматривать подробную информацию о выбранных произведениях искусства. Ниже приведены требования и функциональные возможности, которые необходимо реализовать:

Требования:
Извлекать произведения искусства:

- Создайте функцию, которая извлекает список произведений искусства из API Чикагского института искусств.
Функция должна принимать параметр page для разбивки на страницы и возвращать список произведений искусства вместе с информацией о разбивке на страницы.
Фильтровать произведения искусства:

- Реализуйте функцию, которая фильтрует список произведений искусства на основе имени указанного художника. Функция должна возвращать список работ, которые соответствуют имени художника (без учета регистра).
Отображать подробную информацию об оформлении:

- Напишите функцию, которая отображает названия работ для пользователя и позволяет ему выбрать одну из них, введя соответствующий номер.
После выбора функция должна отображать подробную информацию о выбранном произведении, включая название, исполнителя, дату и носитель.
Разбивка на страницы и взаимодействие с пользователем:

- Создайте основную функцию, которая управляет выборкой произведений и взаимодействием с пользователем.

Разрешите пользователям перемещаться по страницам с произведениями искусства, выполнять фильтрацию по исполнителю или выходить из программы.

Если страниц с произведениями искусства несколько, укажите варианты перехода к следующей странице, предыдущей странице, фильтрации по исполнителю или выхода из программы.
"""

import requests

API_URL = "https://api.artic.edu/api/v1/artworks"

def fetch_artworks(page=1):
    params = {
        'page': page,
        'limit': 10
    }
    response = requests.get(API_URL, params=params)
    if response.status_code == 200:
        data = response.json()
        return data['data'], data['pagination']
    return [], {}

def filter_artworks_by_artist(artworks, artist_name):
    return [artwork for artwork in artworks if artist_name.lower() in artwork['artist_title'].lower()]

def display_artwork_details(artwork):
    print(f"Название: {artwork['title']}")
    print(f"Исполнитель: {artwork['artist_title']}")
    print(f"Дата: {artwork['date_display']}")
    print(f"Носитель: {artwork['medium_display']}")
    print(f"Описание: {artwork.get('description', 'Нет описания')}")
    print(f"Изображение: https://www.artic.edu/iiif/2/{artwork['id']}/full/843,/0/default.jpg")

def main():
    page = 1
    while True:
        artworks, pagination = fetch_artworks(page)
        if not artworks:
            print("Не удалось получить произведения искусства.")
            break

        print("\nСписок произведений искусства:")
        for i, artwork in enumerate(artworks, start=1):
            print(f"{i}. {artwork['title']} (Автор: {artwork['artist_title']})")

        print("\nДоступные действия:")
        print("1. Посмотреть детали произведения искусства")
        print("2. Перейти на следующую страницу" if pagination['has_next_page'] else "2. Следующая страница недоступна")
        print("3. Перейти на предыдущую страницу" if pagination['has_previous_page'] else "3. Предыдущая страница недоступна")
        print("4. Фильтровать по имени художника")
        print("5. Выход")

        choice = input("Ваш выбор: ")

        if choice == '1':
            artwork_index = int(input("Введите номер произведения: ")) - 1
            if 0 <= artwork_index < len(artworks):
                display_artwork_details(artworks[artwork_index])
            else:
                print("Неверный номер произведения.")
        elif choice == '2' and pagination['has_next_page']:
            page += 1
        elif choice == '3' and pagination['has_previous_page']:
            page -= 1
        elif choice == '4':
            artist_name = input("Введите имя художника: ")
            filtered_artworks = filter_artworks_by_artist(artworks, artist_name)
            if filtered_artworks:
                print(f"\nПроизведения художника {artist_name}:")
                for i, artwork in enumerate(filtered_artworks, start=1):
                    print(f"{i}. {artwork['title']}")
            else:
                print("Нет произведений искусства для указанного художника.")
        elif choice == '5':
            print("Выход из программы.")
            break
        else:
            print("Неверный выбор, попробуйте снова.")

if __name__ == "__main__":
    main()

"""# Задание 3

Задача: Создать программу по управлению портфелем криптовалют

Цель: Создать скрипт на Python, который извлекает цены на криптовалюты в режиме реального времени, позволяет пользователям управлять портфелем криптовалют, вычисляет общую стоимость портфеля, отслеживает изменения цен и предоставляет исторические данные о ценах для анализа.

Требования:
Получение текущих цен на криптовалюты:

Используйте https://docs.coingecko.com/ для получения актуальных цен на список криптовалют.

Управление портфелем:

- Позволяет пользователю создавать портфель криптовалют и управлять им, указывая количество каждой криптовалюты, которой он владеет.
- Расчитывает общую стоимость портфеля в указанной фиатной валюте (например, долларах США).

Отслеживание изменения цен:

- Отображение процентного изменения цены для каждой криптовалюты в портфеле за последние 24 часа.
- Выделите все криптовалюты, стоимость которых значительно увеличилась или снизилась.

Поиск исторических данных о ценах:

- Получение исторических данных о ценах на указанную криптовалюту за последнюю неделю.
- Предоставьте пользователю возможность визуализировать эти данные в простом текстовом формате (например, цены за день).

Взаимодействие с пользователем:

- Реализуйте интерфейс командной строки для ввода данных пользователем.
- Предоставьте опции для получения текущих цен, управления портфелем, просмотра изменений цен или анализа исторических данных.
"""

import requests
from prettytable import PrettyTable
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

class CryptoPortfolio:
    def __init__(self):
        self.portfolio = {}
        self.base_url = "https://api.coingecko.com/api/v3"

    def get_current_price(self, crypto_id):

        response = requests.get(f"{self.base_url}/simple/price?ids={crypto_id}&vs_currencies=usd&include_24hr_change=true")
        data = response.json()
        if crypto_id in data:
            return data[crypto_id]['usd'], data[crypto_id]['usd_24h_change']
        else:
            print(f"Ошибка: Криптовалюта '{crypto_id}' не найдена.")
            return None, None

    def add_to_portfolio(self, crypto_id, amount):

        price, change = self.get_current_price(crypto_id)
        if price is not None:
            self.portfolio[crypto_id] = {'amount': amount, 'current_price': price, 'change': change}
            print(f"Добавлено {amount} единиц {crypto_id} в портфель.")

    def remove_from_portfolio(self, crypto_id):

        if crypto_id in self.portfolio:
            del self.portfolio[crypto_id]
            print(f"Удалено {crypto_id} из портфеля.")
        else:
            print(f"{crypto_id} не найден в портфеле.")

    def calculate_total_value(self):

        total_value = 0
        for crypto_id, data in self.portfolio.items():
            total_value += data['amount'] * data['current_price']
        return total_value

    def display_portfolio(self):

        table = PrettyTable()
        table.field_names = ["Криптовалюта", "Количество", "Текущая цена (USD)", "Изменение за 24ч (%)"]
        for crypto_id, data in self.portfolio.items():
            table.add_row([crypto_id, data['amount'], data['current_price'], data['change']])
        print(table)

    def get_historical_data(self, crypto_id):

        end_date = datetime.now()
        start_date = end_date - timedelta(days=7)
        response = requests.get(f"{self.base_url}/coins/{crypto_id}/market_chart/range?vs_currency=usd&from={int(start_date.timestamp())}&to={int(end_date.timestamp())}")
        data = response.json()
        if 'prices' in data:
            return [(datetime.fromtimestamp(item[0] / 1000), item[1]) for item in data['prices']]
        else:
            print(f"Ошибка: Исторические данные для '{crypto_id}' не найдены.")
            return []

    def plot_historical_data(self, crypto_id):

        historical_data = self.get_historical_data(crypto_id)
        if historical_data:
            dates = [item[0] for item in historical_data]
            prices = [item[1] for item in historical_data]

            plt.plot(dates, prices, marker='o')
            plt.title(f"Цена {crypto_id} за последнюю неделю")
            plt.xlabel("Дата")
            plt.ylabel("Цена (USD)")
            plt.xticks(rotation=45)
            plt.tight_layout()
            plt.show()

def main():
    portfolio = CryptoPortfolio()
    while True:
        print("\nМеню:")
        print("1. Добавить криптовалюту в портфель")
        print("2. Удалить криптовалюту из портфеля")
        print("3. Показать портфель")
        print("4. Рассчитать общую стоимость портфеля")
        print("5. Построить график исторических данных для криптовалюты")
        print("6. Выход")

        choice = input("Выберите опцию: ")

        if choice == '1':
            crypto_id = input("Введите ID криптовалюты (например, bitcoin): ").strip().lower()
            amount = float(input("Введите количество: "))
            portfolio.add_to_portfolio(crypto_id, amount)
        elif choice == '2':
            crypto_id = input("Введите ID криптовалюты для удаления: ").strip().lower()
            portfolio.remove_from_portfolio(crypto_id)
        elif choice == '3':
            portfolio.display_portfolio()
        elif choice == '4':
            total_value = portfolio.calculate_total_value()
            print(f"Общая стоимость портфеля: ${total_value:.2f}")
        elif choice == '5':
            crypto_id = input("Введите ID криптовалюты для исторических данных (например, bitcoin): ").strip().lower()
            portfolio.plot_historical_data(crypto_id)
        elif choice == '6':
            break
        else:
            print("Неверный выбор. Пожалуйста, попробуйте снова.")

if __name__ == "__main__":
    main()

"""# Дополнительно: Задание 4

Задание 4: Проектное

Вам необходимо самостоятельно найти откртое API предоставляющее информацию в открытом доступе и реализовать собственный проект!


Критерии приемки результата:

- Проект включает в себя не менее 5 возможостей для пользователя
- Проект позволяет использовать все возможности проекта пользователю при помощи взаимодействия через коммандную строку
- Проект работает с открытым API (это значит что при проверке вашей работы преподавателем, преподавателю необходимо просто запустить ячейку с кодом вашего проекта и она будет работать без дополнительных манипуляции)
- Проект должен обязательно включать в себя ряд используемых конструкции:
    - Функции
    - Условные конструкции
    - Ввод/вывод
    - Словари/Списки
- Допускается использование библиотек:
    - requests
    - datetime
    - random

**Здесь добавьте описание вашего проекта**
"""

#  А здесь код